# 要件定義書

## はじめに

スマートウォッチ向けUI最適化により、小さな円形画面でも情報が見切れず、すべてのUI要素が適切に表示されるようにします。この改善は、既存のCrypto Watch Flutterアプリケーションのスマートウォッチ表示を最適化するものです。

## 用語集

- **システム**: Crypto Watch Flutterアプリケーション
- **ユーザー**: アプリケーションを使用する人
- **スマートウォッチ**: 円形または小型の画面を持つウェアラブルデバイス
- **見切れ**: テキストや要素が画面外にはみ出して表示されない状態
- **オーバーフロー**: コンテンツが指定された領域を超えてしまう状態
- **価格一覧画面**: 複数の暗号通貨の価格を表示するメイン画面
- **価格詳細画面**: 個別の暗号通貨の詳細情報を表示する画面
- **更新ボタン**: 価格データを手動で再取得するためのボタン
- **設定アイコン**: アプリケーション設定画面へのアクセスボタン
- **プルトゥリフレッシュ**: 画面を下にスワイプしてデータを更新する操作
- **ビューポート**: 画面に表示される領域
- **通貨アイコン**: 各暗号通貨を視覚的に識別するためのロゴ画像
- **ティッカーシンボル**: 暗号通貨の略称（例：BTC、ETH、ADA）
- **デフォルト通貨**: システムが初期状態で提供する20種類の主要暗号通貨（BTC、ETH、ADA、BNB、XRP、SOL、DOT、DOGE、AVAX、MATIC、LINK、UNI、LTC、ATOM、XLM、ALGO、VET、ICP、FIL、TRX）
- **カスタム通貨**: ユーザーが検索して追加した任意の暗号通貨
- **お気に入り**: ユーザーが選択して保存した暗号通貨のリスト（デフォルト通貨とカスタム通貨の両方を含む）
- **サジェスト**: ユーザーの入力に基づいて候補を提案する機能
- **外部API**: 暗号通貨の価格データや情報を提供する外部サービス
- **CoinGecko API**: 価格データ、時価総額、24時間変動率を提供する外部API（デフォルト通貨とカスタム通貨の両方に使用）
- **CryptoCompare API**: 暗号通貨のアイコン画像を提供する外部API（デフォルト通貨とカスタム通貨の両方に使用）

## 要件

### 要件1: テキストオーバーフローの防止

**ユーザーストーリー**: ユーザーとして、すべてのテキストが画面内に収まって表示されることを期待する。そうすることで、情報を完全に読み取ることができる。

#### 受入基準

1. WHEN 価格詳細画面が表示される THEN システムはすべてのテキストをビューポート内に収める
2. WHEN テキストが長すぎる THEN システムは省略記号（...）を使用してテキストを切り詰める
3. WHEN テキストが複数行に渡る THEN システムは適切な行の折り返しを適用する
4. WHEN 数値が大きい THEN システムは適切な桁区切りとフォーマットを使用する
5. WHEN テキストがコンテナ幅を超える THEN システムはテキストを画面外にはみ出させない

### 要件2: 価格詳細画面のレイアウト最適化

**ユーザーストーリー**: ユーザーとして、価格詳細画面のすべての情報が適切に配置されることを期待する。そうすることで、画面外にはみ出すエラーを回避できる。

#### 受入基準

1. WHEN 価格詳細画面が表示される THEN システムは24時間高値、安値、出来高の情報を画面内に収める
2. WHEN 追加情報が表示される THEN システムは適切なパディングとマージンを使用する
3. WHEN コンテンツが画面高さを超える THEN システムはスクロール可能にする
4. WHEN 横方向のコンテンツが表示される THEN システムは画面幅の90%以内に収める
5. WHEN デバッグ情報やエラーメッセージが表示される THEN システムはそれらを画面外に配置しない

### 要件3: 設定アイコンの可視性確保

**ユーザーストーリー**: ユーザーとして、価格一覧画面で設定アイコンを確認したい。そうすることで、設定画面にアクセスできる。

#### 受入基準

1. WHEN 価格一覧画面が表示される THEN システムは設定アイコンを画面上部に表示する
2. WHEN 設定アイコンが表示される THEN システムはアイコンを他の要素と重ならないように配置する
3. WHEN 設定アイコンが表示される THEN システムはアイコンのタップ領域を44x44ピクセル以上確保する
4. WHEN 画面上部にナビゲーションバーがある THEN システムは設定アイコンを右上に配置する
5. WHEN 設定アイコンが表示される THEN システムはアイコンを常に可視状態に保つ

### 要件4: 更新ボタンの削除または最小化

**ユーザーストーリー**: ユーザーとして、画面を占有する大きな更新ボタンを削除したい。そうすることで、より多くの価格情報を確認できる。

#### 受入基準

1. WHEN 価格一覧画面が表示される THEN システムは画面右下の大きな更新ボタンを表示しない
2. WHEN ユーザーがデータを更新したい THEN システムはプルトゥリフレッシュ操作を提供する
3. WHEN 自動更新が有効である THEN システムは手動更新ボタンなしで定期的にデータを更新する
4. WHEN 更新ボタンが必要である THEN システムは小さなアイコンボタンとして上部ナビゲーションバーに配置する
5. WHEN 更新操作が実行される THEN システムは視覚的なフィードバック（ローディングインジケーター）を提供する

### 要件5: 円形画面への対応

**ユーザーストーリー**: ユーザーとして、円形のスマートウォッチ画面でもすべての要素が適切に表示されることを期待する。そうすることで、情報の欠落を防げる。

#### 受入基準

1. WHEN 円形画面でアプリが表示される THEN システムは画面の角が切れることを考慮してレイアウトする
2. WHEN 重要な情報が表示される THEN システムは画面中央の安全領域内に配置する
3. WHEN リストアイテムが表示される THEN システムは左右のパディングを十分に確保する
4. WHEN ボタンやアイコンが表示される THEN システムは画面の角を避けて配置する
5. WHEN テキストが表示される THEN システムは円形画面の可視領域内に収める

### 要件6: レスポンシブレイアウトの実装

**ユーザーストーリー**: 開発者として、異なる画面サイズに対応するレスポンシブなレイアウトを実装したい。そうすることで、様々なデバイスで適切に表示できる。

#### 受入基準

1. WHEN 画面サイズが取得される THEN システムは利用可能な幅と高さに基づいてレイアウトを調整する
2. WHEN 小さな画面である THEN システムはフォントサイズとパディングを縮小する
3. WHEN 大きな画面である THEN システムはより多くの情報を表示する
4. WHEN 画面の向きが変わる THEN システムはレイアウトを再計算する
5. WHEN レイアウトが調整される THEN システムは可読性を維持する

### 要件7: フォントサイズの最適化

**ユーザーストーリー**: ユーザーとして、小さな画面でも読みやすいフォントサイズを期待する。そうすることで、情報を快適に読み取れる。

#### 受入基準

1. WHEN 価格が表示される THEN システムは最小14spのフォントサイズを使用する
2. WHEN 重要な情報が表示される THEN システムは18sp以上のフォントサイズを使用する
3. WHEN 補助的な情報が表示される THEN システムは12sp以上のフォントサイズを使用する
4. WHEN フォントサイズが調整される THEN システムは行間を適切に設定する
5. WHEN テキストが複数行に渡る THEN システムは読みやすい行の高さを維持する

### 要件8: パディングとマージンの調整

**ユーザーストーリー**: 開発者として、適切な余白を確保したい。そうすることで、要素が密集せず読みやすいUIを提供できる。

#### 受入基準

1. WHEN リストアイテムが表示される THEN システムは上下に8ピクセル以上のパディングを確保する
2. WHEN リストアイテムが表示される THEN システムは左右に12ピクセル以上のパディングを確保する
3. WHEN セクション間に境界がある THEN システムは16ピクセル以上のマージンを確保する
4. WHEN ボタンが表示される THEN システムは周囲に8ピクセル以上のマージンを確保する
5. WHEN 画面端に要素が配置される THEN システムは画面端から8ピクセル以上の余白を確保する

### 要件9: エラー表示の最適化

**ユーザーストーリー**: ユーザーとして、エラーメッセージが適切に表示されることを期待する。そうすることで、問題を理解できる。

#### 受入基準

1. WHEN エラーが発生する THEN システムはエラーメッセージを画面内に収める
2. WHEN エラーメッセージが長い THEN システムは複数行に分割して表示する
3. WHEN エラーメッセージが表示される THEN システムは適切な背景色とコントラストを使用する
4. WHEN エラーメッセージが表示される THEN システムは閉じるボタンまたは自動消去機能を提供する
5. WHEN デバッグ情報が含まれる THEN システムはそれを画面外に配置しない

### 要件10: ナビゲーションバーの最適化

**ユーザーストーリー**: ユーザーとして、ナビゲーションバーのすべてのアイコンが表示されることを期待する。そうすることで、すべての機能にアクセスできる。

#### 受入基準

1. WHEN ナビゲーションバーが表示される THEN システムはすべてのアイコン（お気に入り、アラート、設定）を表示する
2. WHEN ナビゲーションバーが表示される THEN システムは各アイコンに十分なスペースを確保する
3. WHEN アイコンが多すぎる THEN システムはアイコンサイズを縮小するか、オーバーフローメニューを使用する
4. WHEN ナビゲーションバーが表示される THEN システムはアイコンを均等に配置する
5. WHEN ナビゲーションバーが表示される THEN システムは現在のページを視覚的に示す

### 要件11: スクロール可能領域の明確化

**ユーザーストーリー**: ユーザーとして、どの領域がスクロール可能かを理解したい。そうすることで、隠れた情報にアクセスできる。

#### 受入基準

1. WHEN コンテンツが画面高さを超える THEN システムはスクロールインジケーターを表示する
2. WHEN ユーザーがスクロールする THEN システムはスムーズなスクロールアニメーションを提供する
3. WHEN スクロール可能な領域がある THEN システムは視覚的なヒント（フェードエフェクト）を提供する
4. WHEN スクロールが最上部または最下部に達する THEN システムは視覚的なフィードバックを提供する
5. WHEN スクロール中にユーザーが操作する THEN システムはスクロールを即座に停止する

### 要件12: タッチターゲットサイズの確保

**ユーザーストーリー**: ユーザーとして、小さな画面でもボタンやアイコンを正確にタップしたい。そうすることで、誤操作を防げる。

#### 受入基準

1. WHEN ボタンが表示される THEN システムは最小44x44ピクセルのタップ領域を確保する
2. WHEN アイコンが表示される THEN システムは最小40x40ピクセルのタップ領域を確保する
3. WHEN リストアイテムが表示される THEN システムは最小48ピクセルの高さを確保する
4. WHEN タップ可能な要素が隣接する THEN システムは要素間に4ピクセル以上の間隔を確保する
5. WHEN タップ領域が小さい THEN システムはパディングを追加してタップ領域を拡大する

### 要件13: 動的コンテンツの適応

**ユーザーストーリー**: 開発者として、動的に変化するコンテンツに対応したい。そうすることで、どのようなデータでも適切に表示できる。

#### 受入基準

1. WHEN 価格が大きく変動する THEN システムは数値のフォーマットを調整する
2. WHEN 通貨名が長い THEN システムは名前を省略して表示する
3. WHEN データが欠落している THEN システムはプレースホルダーまたは「N/A」を表示する
4. WHEN データが更新される THEN システムはレイアウトを再計算する
5. WHEN 新しいデータが追加される THEN システムはスクロール位置を維持する

### 要件14: パフォーマンスの維持

**ユーザーストーリー**: ユーザーとして、レイアウト最適化後もアプリが高速に動作することを期待する。そうすることで、快適に使用できる。

#### 受入基準

1. WHEN レイアウトが計算される THEN システムは100ms以内に完了する
2. WHEN 画面が再描画される THEN システムは60FPSを維持する
3. WHEN スクロールが実行される THEN システムは遅延なく応答する
4. WHEN 画面サイズが変更される THEN システムは500ms以内にレイアウトを調整する
5. WHEN 複数の要素が同時に更新される THEN システムはバッチ処理で効率化する

### 要件15: 通貨アイコンの表示

**ユーザーストーリー**: ユーザーとして、各暗号通貨のアイコンを確認したい。そうすることで、通貨を視覚的に素早く識別できる。

#### 受入基準

1. WHEN 価格一覧画面が表示される THEN システムは各通貨のアイコン画像を表示する
2. WHEN 通貨アイコンが表示される THEN システムはアイコンをリストアイテムの左端に配置する
3. WHEN 通貨アイコンが表示される THEN システムは円形の枠内にアイコンを表示する
4. WHEN アイコン画像が取得できない THEN システムはティッカーシンボルの頭文字を含むプレースホルダーを表示する
5. WHEN アイコンが読み込まれる THEN システムはキャッシュを使用してパフォーマンスを最適化する
6. WHEN スマートウォッチ画面である THEN システムはアイコンサイズを32x32ピクセルで表示する
7. WHEN アイコンとテキストが並ぶ THEN システムは適切な間隔（8ピクセル）を確保する
8. WHEN カスタム通貨が追加される THEN システムはデフォルト通貨と同じ方法でアイコンを取得して表示する
9. WHEN カスタム通貨のアイコンが取得できない THEN システムはデフォルト通貨と同じプレースホルダーを表示する

### 要件16: 任意の通貨の検索と追加

**ユーザーストーリー**: ユーザーとして、デフォルトの20種類以外の任意の暗号通貨を検索して追加したい。そうすることで、自分が関心のあるマイナー通貨も追跡できる。

#### 受入基準

1. WHEN ユーザーが通貨追加画面を開く THEN システムは検索フィールドを表示する
2. WHEN ユーザーが検索フィールドに入力する THEN システムはリアルタイムで候補をサジェストする
3. WHEN サジェストが表示される THEN システムは通貨名、ティッカーシンボル、アイコンを含む
4. WHEN ユーザーが検索する THEN システムはCoinGecko APIから利用可能な全通貨を検索する
5. WHEN 検索結果が表示される THEN システムは最大10件の候補を表示する
6. WHEN ユーザーが候補を選択する THEN システムはその通貨をお気に入りに追加する
7. WHEN 通貨が追加される THEN システムはCoinGecko APIからその通貨の価格データを取得して表示する
8. WHEN 通貨が追加される THEN システムはCryptoCompare APIからその通貨のアイコンを取得して表示する
9. WHEN 検索結果が0件である THEN システムは「該当する通貨が見つかりません」というメッセージを表示する
10. WHEN ネットワークエラーが発生する THEN システムは適切なエラーメッセージを表示する

### 要件17: デフォルト通貨とカスタム通貨の管理

**ユーザーストーリー**: ユーザーとして、デフォルトの主要通貨とカスタム追加した通貨を区別して管理したい。そうすることで、整理された状態を維持できる。

#### 受入基準

1. WHEN アプリが初回起動する THEN システムはデフォルト通貨20種類（BTC、ETH、ADA、BNB、XRP、SOL、DOT、DOGE、AVAX、MATIC、LINK、UNI、LTC、ATOM、XLM、ALGO、VET、ICP、FIL、TRX）を表示する
2. WHEN ユーザーがカスタム通貨を追加する THEN システムはそれをローカルストレージに保存する
3. WHEN お気に入りリストが表示される THEN システムはデフォルト通貨とカスタム通貨を区別せず統一的に表示する
4. WHEN ユーザーが通貨を削除する THEN システムはデフォルト通貨もカスタム通貨も削除可能にする
5. WHEN 通貨が削除される THEN システムは確認ダイアログを表示する
6. WHEN アプリが起動する THEN システムは保存されたカスタム通貨を読み込む
7. WHEN カスタム通貨の価格データが取得できない THEN システムは適切なエラー表示を行う
8. WHEN カスタム通貨が追加される THEN システムはCryptoCompare APIからその通貨のアイコンを取得して表示する
9. WHEN カスタム通貨が表示される THEN システムはデフォルト通貨と同じレイアウトとスタイルを適用する
10. WHEN カスタム通貨が選択される THEN システムはデフォルト通貨と同様に詳細画面、お気に入り追加、アラート設定などすべての機能を提供する

### 要件18: 検索サジェスト機能の最適化

**ユーザーストーリー**: ユーザーとして、素早く正確に通貨を検索したい。そうすることで、効率的にお気に入りを管理できる。

#### 受入基準

1. WHEN ユーザーが2文字以上入力する THEN システムはサジェストを開始する
2. WHEN サジェストが実行される THEN システムは300ms以内に結果を表示する
3. WHEN ユーザーが入力を続ける THEN システムは前回の検索をキャンセルして新しい検索を実行する
4. WHEN サジェスト結果が表示される THEN システムは入力文字列に一致する部分をハイライトする
5. WHEN ユーザーが検索フィールドをクリアする THEN システムはサジェスト結果を非表示にする
6. WHEN サジェスト結果が多い THEN システムは人気順または時価総額順でソートする
7. WHEN サジェストが実行される THEN システムは検索結果をキャッシュして再利用する
8. WHEN ユーザーがサジェスト外をタップする THEN システムはサジェストリストを閉じる

### 要件19: ユーザーによるフォントサイズ調整

**ユーザーストーリー**: ユーザーとして、自分の好みに合わせてフォントサイズを調整したい。そうすることで、より快適に情報を読み取れる。

#### 受入基準

1. WHEN ユーザーが設定画面を開く THEN システムはフォントサイズ設定オプションを表示する
2. WHEN フォントサイズ設定が表示される THEN システムは「小」「標準」「大」「特大」の4つのオプションを提供する
3. WHEN ユーザーがフォントサイズを変更する THEN システムはすべてのテキストに新しいサイズを適用する
4. WHEN フォントサイズが変更される THEN システムはテキストが画面外にはみ出さないように自動調整する
5. WHEN フォントサイズが最小値（12sp）を下回る THEN システムは最小値に調整する
6. WHEN フォントサイズ設定が保存される THEN システムは次回起動時も同じ設定を使用する
7. WHEN フォントサイズが変更される THEN システムはレイアウトを再計算する
8. WHEN フォントサイズが「小」である THEN システムはベースサイズの90%を適用する
9. WHEN フォントサイズが「標準」である THEN システムはベースサイズの100%を適用する
10. WHEN フォントサイズが「大」である THEN システムはベースサイズの110%を適用する
11. WHEN フォントサイズが「特大」である THEN システムはベースサイズの120%を適用する

### 要件20: デバッグとテスト

**ユーザーストーリー**: 開発者として、レイアウト問題を簡単に特定したい。そうすることで、迅速に修正できる。

#### 受入基準

1. WHEN デバッグモードが有効である THEN システムはレイアウト境界を表示する
2. WHEN オーバーフローが発生する THEN システムはコンソールに警告を出力する
3. WHEN レイアウトエラーが発生する THEN システムは詳細なエラーメッセージを提供する
4. WHEN テストが実行される THEN システムは異なる画面サイズでレイアウトを検証する
5. WHEN レイアウトが変更される THEN システムはビジュアルリグレッションテストを実行する
